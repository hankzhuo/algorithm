# 数组

数组是一种**线性数据结构**，它用**一组连续的内存空间**，来存储数据。

![](images/01.jpg)

1. 比如数组 var a = new array(10) 来举例，在这个图中，计算机给数组 a，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：公式：`a[i]_address = base_address + i * data_type_size`，其中 data_type_size 表示数组中每个元素的大小。这个例子里，数组中存储的是简单类型数据，所以 data_type_size 就为 4 个字节，数组可以通过下标 i 来查找到某个元素。
2. 低效的插入
   1. 插入：从最好 O(1) 最坏 O(n) 平均时间复杂度为 (1+2+…n)/n = O(n)，最好插入是末尾插入，最坏插入是数组头部，因为要搬移数据，所有插入位置后面的数据都需要往后沿一位。
   2. 插入优化：数组若无序，插入新的元素时，可以将第 K 个位置元素复制到数组末尾，把新的元素，插入到第k个位置替换，此处复杂度为 O(1)。
3. 低效的删除
   1. 从最好 O(1) 最坏 O(n) 平均时间复杂度 O(n)，最好删除是末尾删除，最坏删除是数组头部
   2. 删除优化：多次删除集中在一起，提高删除效率。每次的删除操作并不是搬移数据，只是记录数据已经被删除做个标记，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。

## 数组下标为什么是从 0 开始的？

根据数组公式：`a[i]_address = base_address + i * data_type_size` 为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。也有历史方面的原因。

## 数组与链表的区别？

数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。排好序的数组，你用二分查找，时间复杂度也是 O(logn)。

数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

## 二维数组内存寻址公式

二维数组在内存分配时，并非二维的，也是**连续存储空间**，存完一行，在末尾追了第二行，追加第三行，所以a[m][n]的数组，在内存存储是连续分配了 m*n*type_size 的空间，a[i][j]就是 i行第j个，i行前面有 i*n个数据，所以地址公式为：`a[i]_address = base_address + (i * n + j) * data_type_size`
